# String
1. s1 直接使用常量池的字符串, 不创建新对象  String s1 = "hello"; // 1个对象（常量池中的 "hello"）    
2. s2 和 s3 分别创建 堆中的新对象, 并依赖常量池中的字面量 String s2 = new String("hello"); // 2个对象（常量池的 "hello" + 堆中的新对象）  
3. == 比较的是引用（内存地址）
4. equals() 比较的是内容

# HashMap

## hashmap的设计

链表长度超过 8, 桶数组长度小于 64, 先扩容, 然后转红黑树, 退回链表就是小于 6

- 初始容量: 默认容量 16, 负载因子 0.75, 12 槽满 rehash
- 为什么是 8: 为了扩容和均匀分配, 在负载因子 0.75 条件下, 出现某一链长度为 8 的概率很低, 符合泊松分布
- 为什么负载因子是 0.75: 提高空间利用率和减少查询成本的折中, 0.75 的话碰撞最小。0.75 的时候, 空间利用率比较高, 而且避免了相当多的
  hash 冲突, 使得底层的链表或者是红黑树的高度比较低, 提升了空间效率。负载 0.5 的话树高度低空间利用率高了。如果是 hash 冲突很多
  rehash 的解释: 在创建 hashmap 的时候可以设置来个参数, 默认初始化容量创建 hash 表时桶的数量。当 hash 表中的负载因子达到负载极限的时候,
  hash表会自动成倍的增加容量(桶的数量), 并将原有的对象重新的分配并加入新的桶内, 这称为 rehash
- 1.7 到 1.8 头插法变尾插法, 假如多线程对一个 entry 进行 put 操作, 扩容后链表反转, 不用获取最后一个元素直接出来, 导致 A->B 变为 B->A, 保证 put 安全但是修改还是不安全

## hashmap 为什么会线程不安全

- 判断是否出现 hash 碰撞, 两个线程 A、B 都在进行 put 操作, 并且 hash 函数计算出的插入下标是相同的, A 直接进行插入,
  这就导致了线程 B 插入的数据被线程 A 覆盖了, 从而线程不安全
- 还有个 ++size, 线程A、B, 这两个线程同时进行 put 操作时, AB 线程并发执行可能只增加了 1

## 为什么要重写 hashCode和 equals

- 存入 k1 的时候, 会调用 Object 类的 hashcode 方法, 计算它的 hash 值, 获取对象的地址, 随后把 k1 放入 hash 值所指引的内存位置,
  而 Object 类的 hashcode 方法返回的 hash 值是。由于 k1 和 k2 的内存地址是不一样的, 所以用 k2 拿不到 k1 的值
- 重写 hashcode 方法仅仅能够 k1 和 k2 计算得到的 hash 值相同, 调用 get 方法的时候会到正确的位置去找, 但当出现散列冲突时,
  在同一个位置有可能用链表的形式存放冲突元素, 需要用到 equals 方法去对比了, 由于没有重写 equals 方法,
  它会调用 Object 类的 equals 方法, Object 的 equals 方法判断的是两个对象的内存地址是不是一样, 由于 k1 和 k2 都是 new
  出来的, k1 和 k2 的内存地址不相同, 所以这时候用 k2 还是达不到 k1 的值

## volatile

1. 声明的变量, 更新的时候对其他线程可见, 使用内存屏障保证不会发生指令重排, 解决内存可见性问题  
2. 不保证原子性, 变量被 volatile 修饰后, AB 线程对变量 X 更改后, 会更新到主内存加载最新的值到工作内存,
写操作会导致其他线程中的缓存无效, 任意操作都可能被其他线程干扰

## 深拷贝, 浅拷贝

浅拷贝只复制内存地址, 新旧对象还是共享同一块内存(分支)

# 线程池(ThreadPoolExecutor)

1. 核心线程数 (corePoolSize): 线程池中保持的核心线程数, 即使它们处于空闲状态也不会被销毁
1. 最大线程数 (maximumPoolSize): 线程池中允许的最大线程数
1. 空闲线程存活时间 (keepAliveTime): 线程池中的非核心线程在空闲一段时间后会被销毁, 非核心线程等待被回收时间,
   当线程池中的非核心线程在执行完任务后处于空闲状态超过这个时间时将被终止
1. 任务队列 (workQueue): 用于存储待处理任务的阻塞队列
1. 拒绝策略 (RejectedExecutionHandler): 当线程池无法接受新任务时的处理策略, 常见的拒绝策略包括
    1. AbortPolicy: 抛出 RejectedExecutionException 异常
    1. CallerRunsPolicy: 由调用者线程执行任务
    1. DiscardPolicy: 直接丢弃任务
    1. DiscardOldestPolicy: 丢弃队列中最老的任务, 然后重新提交被拒绝的任务

## 线程池活跃状态
1. 任务执行期间: 当线程正在执行任务时, 该线程处于活跃状态  
2. 任务完成后: 线程完成任务后, 会变为空闲状态, 该线程不再被计入活跃线程数, 活跃线程数会相应减少

## 核心和非核心线程
1. 核心线程: 默认情况下, 即使空闲也会保留在线程池中, 空闲的核心线程不计入活跃线程数
2. 非核心线程: 任务完成后, 如果空闲时间超过 keepAliveTime 设置的值, 线程会被终止, 线程池中的总线程数会减少

## 线程内部状态

1. running: 对应核心线程数, 接收新任务, 处理阻塞队列的任务, 如果不手动调用关闭方法, 那么线程池在整个程序运行期间都是此状态
2. shutdown: 不接收任务, 将已保存在任务队列中的任务处理完
3. stop:  不接受任务, 不处理阻塞队列的任务, 线程池状态变为stop, 中断工作和空闲线程, 丢弃工作队列中存量任务
4. tidying:  线程池任务为空,整理状态, 所有的任务都执行完毕后, terminated()
5. terminated:  销毁状态, 当执行完线程池的 terminated() 方法之后就会变为此状态

![线程池状态.png](线程池状态.png)

## Tomcat 线程池

IO 密集型, 期望任务堆积时, 优先创建线程来处理, 而不是入队, 线程数增加时候, jdk 是入队, tomcat 是创建新的线程执行任务

# Synchronized锁 :

## 锁升级

1. 无锁: 现场没获取 Synchronized 锁的状态
2. 偏向锁: 即偏向第一个拿到锁的线程, 锁会在对象头的 Mark Word 通过 CAS(Compare And Swap)记录获得锁的线程id, 同时将Mark
   Word 里的锁状态置为偏向锁, 是否为偏向锁的位置为 1,
   当下一次还是这个线程获取锁时就不需要通过 CAS。如果其他的线程尝试通过 CAS 获取锁(即想将对象头的 Mark Word 中的线程 ID
   改成自己的) 会获取失败, 此时锁由偏向锁升级为轻量级锁
3. 轻量级锁: JVM 会给线程的栈帧中创建一个锁记录(Lock Record)的空间, 将对象头的 Mark Word 拷贝到 Lock Record 中,
   并尝试通过 CAS 把原对象头的 Mark Word 中指向锁记录的指针指向当前线程中的锁记录
4. 自旋锁: 轻量级锁升级为重量级锁之前, 线程执行 monitor enter 指令进入 Monitor 对象的 EntryList 队列, 此时会通过自旋尝试获得锁,
   如果自旋次数超过了一定阈值(默认10), 才会升级为重量级锁, 等待线程被唤起
5. 重量级锁

----

## 锁降级

写线程获取写入锁后可以获取读取锁, 然后释放写入锁, 这样就从写入锁变成了读取锁, 从而实现锁降级的特征, 保证数据的可见性

**为什么降级**

1. 为了保证数据可见性。假设线程A修改了数据, 释放了写锁, 这个时候线程T获得了写锁, 修改了数据, 然后也释放了写锁,
   线程A读取数据的时候, 读到的是线程T修改的, 因此通过锁降级来保证数据每次修改后的可见性
3. 比如 AB 线程改一个数据 i, 依次+1, Thread-0 释放了写锁后, 由于 Thread-0 还拥有着读锁, Thread-1 并不能获取写锁篡改 i
   的值, 保证了 i 的值修改后的可见性

synchronized(排他锁):  在对象头设置标记实现

+ Monitor: EntryList + Owner + WaitSet 组成
+ EntryList: 当多个线程同时访问一个 Monitor 对象时, 这些线程会先被放进 EntryList 队列, 此时这些线程处于Blocked状态,
+ Owner: 当一个线程获取到了这个 Monitor 对象时, Owner 会指向这个线程, 当线程释放掉 Monitor 对象时, Owner 会置为null,
+ WaitSet: wait 方法时, 当前线程会释放对象锁, 同时该线程进入 WaitSet 队列, Monitor 对象还有一个计数器 count 的概念,
  这个 count 是属于 Monitor 对象的, 当 Monitor 对象被某个线程获取时, ++count, 当 Monitor 对象被某个线程释放时, --count

# 为什么有泛型擦除

编译时, 避免使用强制类型转换。全都统一成 Object 类, 主要是为了兼容以前的工具类

# 线程状态

+ NEW(初始), 新建状态, 线程被创建出来, 但尚未启动时的线程状态
+ RUNNABLE(就绪状态), 表示可以运行的线程状态, 它可能正在运行, 或者是在排队等待操作系统给它分配 CPU 资源
+ BLOCKED(阻塞), 阻塞等待锁的线程状态, 表示处于阻塞状态的线程正在等待监视器锁, 比如等待执行 synchronized 代码块或者使用
  synchronized 标记的方法
+ WAITING(等待), 等待状态, 一个处于等待状态的线程正在等待另一个线程执行某个特定的动作, 比如, 一个线程调用了
  Object.wait()方法, 那它就在等待另一个线程调用 Object.notify() 或
  Object.notifyAll()方法
+ TIMED_WAITING(超时等待): 不同于WAITING,无需等待其它线程显式地唤醒, 在一定时间之后会被系统自动唤醒
+ TERMINATED, 终止状态, 表示线程已经执行完成
+ 等待队列: wait 进入等待队列, notifyAll 唤醒所有线程, 所有线程进入锁池, 锁池里面放的都是想争夺对象锁的线程

# 阻塞队列:

ArrayBlockingQueue
> 1. 数组阻塞队列, 这个队列是一个有界队列, 遵循FIFO, 尾部插入, 头部获取
> 2. 初始化时需指定队列的容量 capacity
> 3. 类比到上面的场景, 就是椅子的数量为初始容量capacity
----
LinkedBlockingQueue
> 1. 链表阻塞队列, 这是一个无界队列, 遵循FIFO, 尾部插入, 头部获取
> 2. 初始化时可不指定容量, 此时默认的容量为Integer.MAX_VALUE, 基本上相当于无界了, 此时队列可一直插入(如果处理任务的速度小于插入的速度,
     时间长了就有可能导致OOM)
> 3. 类比到上面的场景, 就是椅子的数量为Integer.MAX_VALUE

SynchronousQueue
> 1. 同步队列, 阻塞队列的特殊版, 即没有容量的阻塞队列, 随进随出, 不做停留
> 2. 类比到上面的场景, 就是椅子的数量为0, 来一个人就去柜台办理, 如果柜台满了, 就拒绝

PriorityBlockingQueue
> 1. 优先级阻塞队列, 这是一个无界队列, 不遵循FIFO, 而是根据任务自身的优先级顺序来执行
> 2. 初始化可不指定容量, 默认11(既然有容量, 怎么还是无界的呢？因为它添加元素时会进行扩容)
> 3. 类比到上面的场景, 就是新来的可以插队办理业务, 好比各种会员

DelayQueue
> 1. 基于优先队列, 最小堆结构, 队首元素是最先到期元素, 取出元素如果到期就可以取出
> 2. 调度线程: 通常会有一个或多个线程不断检查队列中的元素是否已经到期, 一旦发现到期的元素就会将其取出并处理
> 3. Leader/Followers模式: 只有当前领导线程（Leader）会等待到期的元素, 其他线程（Followers）处于等待状态。当领导线程唤醒时,
     它会选出一个新的领导线程, 自己则去处理到期的元素

# 问题

1. OOM、死锁、超时问题可以再运维层面改配置、重启、扩容等手段解决
2. 缓存击穿、多线程环境使用非线程安全的类, 在多线程高并发情况才会暴漏问题
3. 性能问题不会导致明显的 bug, 让程序运行缓慢、内存使用增加, 量变到质变瞬间爆发

# 常见 bug

## spring 配置注入 bean, 配置缺省(系统默认状态)

单线程测试正常, 多线程各种异常, 默认的 bean 是单例的, 多线程调用线程不安全

## 超时自动释放避免重复

1. 避免超时, 锁续期, 如 redission 的 watchdog, 单独开一个线程给锁延长有效期, 设置锁有效期 30s,线程每 10s 重新设置下有效期
2. 避免重复, 增加标记表示字段是否被处理, 或者开新的表保存处理过的流水号
    1. 场景是, A和B 买可乐和雪碧遇到死锁, 10s后锁释放了, B买雪碧, 但同时 C 获取了可乐锁, 被重复购买

# spring 的事务

## @Transactional 生效原则

1. public 方法生效, spring 默认通过动态代理方式实现 private 无法被动态代理到
2. 必须通过代理过的类从外部调用目标方法才能生效

# 序列化

1. RedisTemplate: 使用 JDK 序列化
2. StringRedisTemplate: 使用 String 序列化

# 安全问题

1. 使用 IP 定位不准确, 网吧、学校、公司等机构的出口 IP 是同一个, 最好的是用微信第三方授权登录去做一个唯一性判断
2. 每一个需要登陆的方法, 从 session 获得用户标识
3. 使用开放的、面向用户的平台资源要考虑防刷, 主要包括正常使用流程识别、人机识别、单人限量和全局限量等手段
4. 后端幂等控制, 根据 token, 客户端的序列号, 有意义的业务订单号
5. 根据幂等依据进行防重处理
    1. 限制: 锁方式
    2. 去重方式
6. 监控报警, 做好报警阈值处理
7. 先有订单再有资金操作
8. 短信防刷
    1. 固定请求头才能发验证码, 爬虫只能抓取 URL, 很难分析额外请求头
    2. 注册页面才能发送验证码
    3. 相同手机号发送次数和频次

# 注入攻击

1. 客户端给服务端的查询值, 注入数据成为 SQL 一部分叫做 SQL 注入, cookie 也可以
2. 规则引擎会用动态语言做一些计算, 和 SQL 注入一样外部传入的数据只能当作数据使用, 叫代码注入
3. 用户注册、留言、评论等功能服务端从客户端收集信息, 替换了 javascript 代码, 服务端可能将此类代码保存到数据库, 叫 XSS 攻击

## 打印 SQL 语句

<groupId>com.github.gavlyukovskiy</groupId>

## HTTPS

HTTP 协议传输的是明文

HTTPS 网站管理员需要申请并安装 CA 证书到服务端, 其中包含加密公钥, 网站域名等信息, 私钥服务端自己保存不会公开
根部证书只要为数不多的机构可以生成, 预置在 OS 中, 没办法伪造, 提取公钥验证中间证书的签名, 拿到中间证书的公钥验证用户证书签名  
网站设计敏感数据传输使用 HTTPS 协议

HTTPS 之所以安全是因为非对称加密和最后握手成功后拿到的是一个不确定的字符串作为对称密钥的

# 抽象类和接口
## 使用抽象类的情况

1. 需要在多个相关类间共享代码
2. 需要声明非静态、非 final 的字段
3. 需要定义除 public 外的访问权限
4. 需要定义构造方法
5. 设计类层次结构, 有明确的"is-a"关系

## 使用接口的情况

1. 定义行为规范, 不关心具体实现
2. 需要多重继承行为(一个类实现多个接口)
3. 定义 API 供不同实现使用
4. 希望实现松耦合设计
5. 需要定义回调机制(如事件监听)

# 后端架构

1. 数据太多一个表存性能差怎么办, 分表, 一台机器硬盘存不下怎么办, 分库, 请求太多一个机器扛不住怎么办, 分片
2. 请求太多了库扛不住怎么办, 上缓存 redis, 数据多了一台机器内存不够怎么办, redis集群
3. 上了缓存, 就要面临缓存和库数据一致性的问题
4. 应对大流量, 消息队列除了能在系统设计层面解耦, 还能削峰
5. 一个节点扛不住怎么办, 部一堆节点, 分布式
6. 分布式那么多节点怎么管理, 靠分布式协调比如 zk
7. 多个节点加锁, 分布式锁
8. 一个服务太臃肿, 各功能模块流量不等, 拆微服务
9. 各个微服务之间数据一致性怎么保证, 靠分布式事务
10. 各个微服务之间通信, 靠消息队列和 http
11. http 慢, 靠 rpc, thrift, tcp http2 等, 各个服务语言不统一, 得跨语言如 grpc (移动设备)
12. 这么多微服务好几百个怎么管理啊, 靠 spring cloud
13. 我怎么知道该请求哪台机器啊, 那么多机器今天上一个明天下一个的, 靠服务发现
14. 调用链那么长, 怎么知道哪出问题了, 靠全链路监控
15. 调用链那么长, 怎么知道瓶颈在哪里, 靠全链路压测
16. 下游挂了把我拖垮怎么办, 熔断
17. 流量突增, 业务扛不住, 限流
18. 流量突增, 得保核心服务, 降级
19. 重启解决 99% 问题, 服务不可能有问题, 大部分是网络的问题