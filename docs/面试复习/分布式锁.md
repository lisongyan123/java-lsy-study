# 分布式锁

理论上来说, 任何一个有状态的服务都可以做分布式锁, 只要记录好状态就行

# redis 的分布式锁

1. 可重入: 进程id + 线程id + 加锁次数, 每次获取加锁count + 1, 新的值设进去, 那么有可能设置的时候超时了再设置进去, 产生并发问题, 可用 Redisson 解决这个问题
2. 死锁: 加过期时间, 保证加锁和时间的原子性, 使用 setnx
3. 锁过期: java 用 redission, 默认加锁 30s (防止客户端挂了, 不能释放锁), 每10s自动续期, 守护进程定期刷新锁过期时间

# redis分布式锁缺点

1. redis 是 AP 主从同步时无法保证强一致性
2. java 的 gc 可能将锁回收导致过期

## redission 实现分布式锁

1. 获取当前时间戳
2. 轮流用相同的 key 和随机值在 N 个节点上请求锁, 在这一步里, 客户端在每个 master 上请求锁时, 会有一个和总的锁释放时间相比
   小的多的超时时间, 比如如果锁自动释放时间是10秒钟, 那每个节点锁请求的超时时间可能是5-50毫秒的范围, 这个可以防止一个客
   户端在某个宕掉的 master 节点上阻塞过长时间, 如果一个 master 节点不可用了, 我们应该尽快尝试下一个 master 节点
3. client 通过获取所有能获取的锁后的时间减去第一步的时间, 这个时间差要小于 TTL 时间并且至少有一半以上个 redis 实例成功获取锁, 才算真正的获取锁成功
4. 如果成功获取锁, 则锁的真正有效时间是 TTL 减去第三步的时间差的时间, TTL 是 5 s,获取所有锁用了 2 s,则真正锁有效时间为 3 s(其实应该再减去时钟漂移)
5. 如果客户端由于某些原因获取锁失败, 便会开始解锁所有 redis 实例, 因为可能已经获取了小于3个锁, 必须释放, 否则影响其他 client 获取锁

## redission 实现思路
基于 netty, 使用 watch dog 实时监听, 过期自动续时

## redission 分布式锁类型
1. 可重入锁
2. 公平锁
3. 联锁
4. 红锁
5. 读写锁
6. 信号量
7. 可过期信号量
8. 闭锁(/倒数闩)

# redis分布式锁优化方案

## 方案1

不设置过期时间, 可重入锁+异常重试 避免死锁和key过期的问题
异常重试: 用mq, 生产者生成 requestId, 做幂等性 多个资源请求放到 mq 队列等待
可重入: 缓存value为requestId, 如果和当前消息中requestId一致可释放锁, 保证幂等性

## 方案2

不需要设置过期时间, value放时间戳, 线程A如果setnx成功那么就说明锁成功, 
setnx失败取出value和当前时间比较, 没超过设置超时时间也是锁成功, 处理完了删锁
也可用incr来做, 因为incr是原子性的, 比如如果incr为1表示成功

## 方案3

每个锁打开一个线程去监测过期时间, 准备过期而且任务没完成的重新expire, 但是可能会创建很多线程炸了CPU
锁放一个优先队列, 按过期时间排序, 定时 5s 去队列扫面快过期的锁, 重新续期并放入队列
redis2.9 版本的 set-nx-expire 保证原子性

# 分布式锁选择方案

1. 允许容错首选基于 gossip 协议的 redis 缺点是各个机器有钟摆
2. 其次选择基于 raft 协议的 etcd

# redis 锁的 value 用 uuid
1. 锁的拥有者的作用是, 解锁的时候的身份验证
2. 两个方法都加了分布式锁 一个调用另一个的时候, 不需要uuid去判断是否可重入么
3. 不会产生死锁, 需要判断这把锁是否是自己的, 防止别人把你的锁 unlock 