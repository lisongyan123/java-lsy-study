# jvm内存模型

1. 程序计数器: 让jvm知道执行到哪个字节码, 从哪开始执行
2. 本地方法栈: 虚拟机用到的 native 方法服务 sof 和 oom
3. 虚拟机栈: 局部变量, 操作数, 动态链接, 方法返回地址
4. 堆: 存放对象实例, 静态变量在堆中 xmx 和 xms 控制
5. 本地内存元空间: 常量池在元空间还有 class 文件
    1. 老年代:  2/3
    2. 年轻代: 1/3
    3. eden: survivor0 : survivor1 = 8 : 1 : 1

# 新生代晋升为老年代

- 对象优先分配在 eden 区, eden 区满时会触发一次 minor GC, 长期存活的对象进入老年代, 对象每熬过一次 GC 年龄+1(默认年龄阈值15, 可配置),
  对象太大新生代无法容纳则会分配到老年代 GC 进行时, Eden 区所有存活的对象都被复制到 To Survivor 区, 而 From Survivor 区中,
  根据年龄值 (默认15是因为对象头中年龄战 4 bit, 新生代每熬过一次垃圾回收, 年龄+1), 则移到老年代, 没有达到则复制到 To Survivor

## Young GC

1. 内存不足:
   当年轻代中的 Eden 区没有足够的连续空间来分配新对象时, 会触发 Young GC。Eden 区是年轻代中最初分配新对象的地方。
2. 对象晋升失败:
   如果 Survivor 区（年轻代中的两个区域之一, 用于存储经过一次或几次 Young GC 后仍然存活的对象）满了, 无法容纳从 Eden 或另一个
   Survivor 区晋升过来的对象, 也会触发 Young GC。
3. 对象分配速率过高:
   如果应用程序创建对象的速度超过了垃圾收集器清理的速度, 可能会导致频繁的 Young GC。
4. JVM 参数配置:
   JVM 提供了一些参数可以控制 Young GC 的行为, 比如 -Xmn 设置年轻代大小, -XX:MaxTenuringThreshold
   设置对象晋升到老年代之前的存活次数等。调整这些参数可能会影响 Young GC 的频率和效率。
5. TLAB (Thread Local Allocation Buffer) 溢出:
   每个线程都有一个 TLAB, 用于减少多线程环境下的锁竞争。当 TLAB 耗尽时, 线程需要从 Eden 区分配新的 TLAB, 如果此时 Eden
   区不够大, 就会触发 Young GC。
6. 元数据区/永久代溢出:
   在某些情况下, 即使年轻代本身没有满, 但如果元数据区（Metaspace, 在 Java 8 及之后版本中取代了永久代）
   , 也可能间接地触发 Young GC, 因为这可能导致整个堆的重新组织
操作，例如类卸载（Class Unloading）、内存压缩（Heap Compaction）等，也可能触发 Full GC。

# GC roots 对象

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性, 一般指被 static 修饰引用的对象, 加载类的时候就加载到内存中
3. 方法区中的常量引用的对象
4. 本地方法栈中 JNI (native方法) 引用的对象

# 栈和堆

- 栈解决程序的运行问题, 即程序如何执行, 或者说如何处理数据(局部变量(含形参)、程序运行状态、方法返回值)
- 堆解决的是数据存储的问题, 即对象数据怎么放、放在哪儿
- test: 为对象引用, 存在栈中, 对象(new Test())存在堆中
- 栈中, 存放的是基本数据类型和堆中对象的引用, 而堆中, 存放的则是对象, String 字符串的放到堆中常量池里面

# new 对象的过程

1. 虚拟机遇见 new 时候, 判断是否已经加载, 没加载执行类的加载机制, 加载完给对象分配空间、初始化, 双亲委派模型,
   类加载器收到了类加载请求, 委托给父类, 所有加载请求会委托给启动类加载器, 保证全局唯一性
2. 加载: 从字节码加载成二进制流
3. 验证: 校验 Class 文件是否符合虚拟机规范, 和接口一样, 进行参数校验
4. 准备: 为静态变量、常量赋默认值
5. 解析: 常量池中符号引用替换为直接引用(编译方面, 说不明白)
6. 初始化: 执行 static 代码块进行初始化, 存在父类, 对父类初始化
7. 使用
8. 卸载

**PS:**
静态代码块是绝对线程安全的, 只能隐式被 java 虚拟机在类加载过程中初始化调用

# 类加载器

1. Bootstrap ClassLoader 启动类加载器, 默认会去加载JAVA_HOME/lib目录下的jar
2. Extention ClassLoader 扩展类加载器: 默认去加载JAVA_HOME/lib/ext目录下的jar
3. Application ClassLoader 应用程序类加载器: 比如我们的 web 应用, 会加载 web 程序中 ClassPath 下的类,以及 main 函数所在的类的
   class 文件
4. User ClassLoader 用户自定义类加载器: 用户自己定义

![](类加载机制.png)

# 双亲委派机制由图所示

1. 防止重复加载同一个.class, 通过委托去向上面问一问, 加载过了, 就不用再加载一遍。保证数据安全
2. 保证核心.class不能被篡改, 通过委托方式, 不会去篡改核心.class, 即使篡改也不会去加载, 即使加载也不会是同一个.class对象了,
   不同的加载器加载同一个.class也不是同一个Class对象,
   这样保证了Class执行安全

----

# 垃圾回收算法

- 标记清除: 标记出要回收的对象, 标记完后统一回收所有被标记的对象, 标记过程要遍历所有的根对象, 清除过程遍历堆中所有对象。效率低下,
  带来了内存碎片问题
- 复制算法: 内存分大小相等两块, 先用其中一块, 内存使用完了, 将存活对象拷贝到另外一块内存, 当前内存清空, 性能和内存碎片问题解决,
  可用内存空间缩小一半, Eden+S0+S1组成, 因为根据IBM的研究显示, 98%的对象都是朝生夕死 所以默认8: 1: 1
- 标记整理: 老年代存活率比较高, 频繁复制比较大了, 标记整理后存活对象都向一端移动, 再清理边界以外的内存空间

# 如何避免 full gc

比如 common poll 使用对象池技术, 可以复用池中对象, 没有分配内存和创建堆中对象的开销, 没有释放内存和销毁堆对象的开销,
减少垃圾收集器的负担, 避免内存抖动, 不必重复初始化对象状态

# 垃圾回收器选型

1. G1 GC是基于 Region 的 GC, 适用于大内存机器, 即使内存很大, Region扫描, 性能还是很高的
2. CMS 追求停顿时间越短越好, 对 cpu 性能要求高同时对内存要求不高, cpu 性能好但是内存不大可以用 cms

# pod 的 jvm 配置参数

jvm 达到 xmx 之后, 跟你 pod 剩余的内存就没关系了, jvm 配置 pod 90%
jvm 要是达到了 xmx 配置的最大内存之后, 对你的 pod 来说, 就相当于已经完全分配了 xmx 出去了, jvm 不会在还回去

# 实际问题

pod 16G 16核 8 pod 多分点内存

jstat -gcutil pid 2s 观察堆内存情况

jmap pid 触发 fullgc 假死的服务器就活了

或者 grep '异常' *.log 或者 直接 less *.log |grep '异常'
