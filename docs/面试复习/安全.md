# 认证

## 密码认证

1. 数据库明文存储, 拿请求参数对比, 被黑客脱库
2. 加密算法, 将密码翻译, 如果可逆, 黑客识别规律还原密码
3. 使用不可逆加密算法 MD5、SHA-1, 但是不够严谨, 黑客可以通过暴力枚举、字典、彩虹表等手段破解密码, LinkedIn 在 2012 年 650w
   用户密码泄露, 黑客 3 天暴力破解 90% 密码
4. 使用 SHA-256, 输出位数更多, 更消耗 CPU
5. 在每个用户密码 hash 值计算过程中, 引入随机、较长的加盐(salt)参数, 让相同密码输出不同结果, 让彩虹表失效
6. 彩虹表是黑客破解密码的一种方法之一, 预加载了常用密码使用 MD5/SHA-1 计算的 hash 值, 可通过 hash 值匹配快速破解密码
7. 增加 hash 值计算过程的开销, 比如循环迭代多次, 增加破解时间成本
8. 避免频繁、昂贵的密码计算匹配, 后续请求携带 token, 加过期时间, 缩小数据泄露的时间窗口, 在性能上、安全性上实现平衡

## 证书

1. 密码认证一般在 client 和 server 基于 http 协议通信的内网场景、对安全有更高要求时, 使用 https 协议加密通信数据
2. Https 使用非对称加密实现身份认证和密钥协商, 使用 https 协议你需要使用 CA 证书给 client 才能访问
3. 证书在稳定性、性能上都优于密码认证, 稳定性不存在 token 过期
4. 密码鉴权简单易用、证书略麻烦、需要为多个租户设置不一样证书, 独立生成

## CSRF 攻击过程

1. 假设用户 A 登录银行的网站进行操作, 同时也访问了攻击者预先设置好的网站, 恶意软件让浏览器向已完成用户身份认证的网站发起请求,
   执行有害操作跨站请求伪造攻击
2. 用户 A 点击了攻击者网站的某一个链接, 这个链接是 http://www.bank.com/xxx指向银行, 银行服务器根据这个链接携带的参数会进行转账操作
3. 银行服务器在执行转账操作之前会进行 Session 验证, 但是由于用户 A 已经登录了银行网站,
   攻击者的链接也是 http://www.bank.com, 所以攻击的链接就会携带 session 到服务器
4. 由于 session id 是正确的, 所以银行会判断操作是由本人发起的, 执行转账操

### 理解

利用浏览器携带的 cookie 登录态搞事情, 要么不使用 cookie 记录状态, 要么当作登录态窃取问题进行解决(
短信校验、人工审核、交易密码)

## CSRF 防范手段

1. 验证 HTTP Referer 字段: Referer来源地址的校验可以识别出恶意域名
2. 在请求地址中添加 token 并验证: 要求用户浏览器提供不是保存在 cookie 中并且攻击者无法伪造的数据作为校验条件
3. 在HTTP头中自定义属性并验证: 使用 token 并进行验证, 和上一种方法不同的是, 这里并不是把 token 以参数的形式置于 HTTP
   请求之中, 而是把它放到 HTTP 头中自定义的属性里
4. 如果满足会话保持, 就无法 100% 防止 csrf 伪造请求攻击, 什么 refer,token,header 等方法都没有用, 解决方案只有一个,
   那就是按照请求的功能的重要程度, 危险程度, 影响程度来做检验, 检验方式包括输入密码, 短信验证码, 扫描二维码, 静态口令卡,
   一次性token口令卡或动态口令卡, 让用户实时感知浏览器正在请求我们的网站服务, 但具体是不是用户本人发出的, 由用户自己做决定
5. csrf-token, 拿到 cookie 也会被拒绝, csrf 绑定 session

## XSS 攻击

恶意脚本注入请求输入中, 攻击者通过注入恶意脚本进行攻击行为比如搜集数据

## cors

开发者只需要从客户端发出之后的安全问题, 比如用 tls 防范传输过程中数据被修改, 用 cors 防止 csrf, 用 httponly cookie 防止 xss

## DDOS(拒绝服务攻击)

利用大量合理请求来占用过多目标资源, 使目标服务无法相应正常请求
目前已知的最大流量攻击, 去年 Github 遭受的 DDOS 攻击, 其峰值流量已经达到了 1.35Tbps, PPS 更是超过了 1.2 亿

### 攻击类型

1. 耗尽带宽
2. 耗尽操作系统资源
3. 耗尽应用程序运行资源(应用程序处理无效请求)

### 缓解方法

1. 程序识别, 拒绝恶意流量, 利用缓存、增加 WAF、使用 CDN
2. 购买专业的流量清洗设备和网络防火墙, 在网络入口处阻断恶意流量, 只保留正常流量进入数据中心的服务器中

## token

解决无法伪造用乎凭证的问题

1. token 被偷主要靠 https 来防止, https 保护了通信数据, xss 不知道 token 就无法注入脚本
2. 减少 token 被偷的危害可以把 token 有效期缩短 比如 60s, 用另一个长效 token 刷新, 或者新颁发短效 token
3. xss 可以通过 js 获取 cookie 或者 local storage, 一般不用 cookie 来安全认证, xss 能获得本站 local storage 但不能跨站,
   token 保护本站
4. csrf 不能获得 local storage, 因为有同源保护, 不同网站的 localstorage 隔离, csrf 恶意网站执行 js 代码依旧在恶意网站域执行,
   拿不到正常网站 localstorage 数据

### 传输过程

使用 access_key 和 secret_key 双重验证, 保证数据传输可校验

Access_key 是可见的, 但 secret_key 是不可见的, 穿过去的数据带一个加密的校验包, 然后用 Access 反查 secret , 解密校验包, 看看是否和传参一致

## 抓包

简单说是不给抓包, 原理上是避免中间人攻击, 截取了通信数据无法解密, 比如浏览器 F12 也叫抓包

# 安全防范

应用层的需要安全编码, 避免不可信的输入造成 sql 注入 xxe xss csrf 未授权和逻辑漏洞等等

ddos 这种拒绝服务攻击得靠安全设备来防了

ddos 和 cc 是没法防的, 只能硬抗, 云防护

xss 像小偷需要防但对方总能进到你屋子里, xss 对请求报文过滤下

# 拿到 cookie 登录系统

**以下系统拿到 cookie 仍然无法登录**

1. 白名单系统
2. 我们的 cookie 会与 ip地址与user-agent 联动检查, 遇到可疑的异地冒用情况会踢出登陆
3. 我们的管理员后台是只能 office 访问(slb做了ip白名单), 无法外部访问
4. 我们系统的管理页面 cookie 是1小时过期, 你虽然拿到了我的 cookie, 但是我在一小时之内都没登陆过, 你拿到的是过期 cookie,
   进不去我们系统的后台, 即使进去了, 高手也很难在1h 内写出爬虫代码
5. api 用了带 body 签名验证的协议, 好处是规则复杂, 你有了 cookie 也无法用 python 等爬虫类程序冒用他人身份请求我们的接口
6. cookie 启用了严格的 same-site, 并且是 httpOnly 的, 这意味着你无法通过 js 代码, 或者其他钓鱼获取到用户 cookie
7. httponly 的应用场景是为了防止 XSS 攻击, 没有对 <> 进行转义, 其他人打开页面也被执行了, 但是拿到了身份 cookie 不一定能登录,
   因为有二次认证